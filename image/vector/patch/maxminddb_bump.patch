From 44c8f1cfd Mon Sep 17 00:00:00 2001
From: Enin <enin.kaduk@docker.com>
Date: Thu, 11 Dec 2025 12:11:56 +0100
Subject: [PATCH] Bump maxminddb to 0.27.0

---
 Cargo.lock                    |  4 ++--
 Cargo.toml                    |  2 +-
 src/enrichment_tables/geoip.rs | 60 ++++++++++++++++++------------------------
 src/enrichment_tables/mmdb.rs  |  4 ++--
 4 files changed, 32 insertions(+), 38 deletions(-)

diff --git a/Cargo.lock b/Cargo.lock
index 1b1c9170d..920277ba6 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -6318,9 +6318,9 @@ dependencies = [

 [[package]]
 name = "maxminddb"
-version = "0.26.0"
+version = "0.27.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2a197e44322788858682406c74b0b59bf8d9b4954fe1f224d9a25147f1880bba"
+checksum = "7ef0551fc3e7345a6c854c1026b0ddada1e443e51f4fb4cdcf86cc1a71d4b337"
 dependencies = [
  "ipnetwork",
  "log",
diff --git a/Cargo.toml b/Cargo.toml
index 040d94a55..de4529d29 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -383,7 +383,7 @@ k8s-openapi = { version = "0.22.0", default-features = false, features = ["v1_26
 kube = { version = "0.93.0", default-features = false, features = ["client", "openssl-tls", "runtime"], optional = true }
 listenfd = { version = "1.0.2", default-features = false, optional = true }
 lru = { version = "0.16.0", default-features = false }
-maxminddb = { version = "0.26.0", default-features = false, optional = true, features = ["simdutf8"] }
+maxminddb = { version = "0.27.0", default-features = false, optional = true, features = ["simdutf8"] }
 md-5 = { version = "0.10", default-features = false, optional = true }
 mongodb = { version = "2.8.2", default-features = false, features = ["tokio-runtime"], optional = true }
 async-nats = { version = "0.42.0", default-features = false, optional = true, features = ["ring"] }
diff --git a/src/enrichment_tables/geoip.rs b/src/enrichment_tables/geoip.rs
index 96f24fda1..bbf6b14c0 100644
--- a/src/enrichment_tables/geoip.rs
+++ b/src/enrichment_tables/geoip.rs
@@ -4,7 +4,7 @@
 //!
 //! [maxmind]: https://dev.maxmind.com/geoip/geoip2/downloadable
 //! [geolite]: https://dev.maxmind.com/geoip/geoip2/geolite2/#Download_Access
-use std::{collections::BTreeMap, fs, net::IpAddr, path::PathBuf, sync::Arc, time::SystemTime};
+use std::{fs, net::IpAddr, path::PathBuf, sync::Arc, time::SystemTime};

 use maxminddb::{
     Reader,
@@ -129,10 +129,10 @@ impl Geoip {
         // Check if we can read database with dummy Ip.
         let ip = IpAddr::V4(std::net::Ipv4Addr::UNSPECIFIED);
         let result = match dbkind {
-            DatabaseKind::Asn | DatabaseKind::Isp => dbreader.lookup::<Isp>(ip).map(|_| ()),
-            DatabaseKind::ConnectionType => dbreader.lookup::<ConnectionType>(ip).map(|_| ()),
-            DatabaseKind::City => dbreader.lookup::<City>(ip).map(|_| ()),
-            DatabaseKind::AnonymousIp => dbreader.lookup::<AnonymousIp>(ip).map(|_| ()),
+            DatabaseKind::Asn | DatabaseKind::Isp => dbreader.lookup(ip).and_then(|r| r.decode::<Isp>().map(|_| ())),
+            DatabaseKind::ConnectionType => dbreader.lookup(ip).and_then(|r| r.decode::<ConnectionType>().map(|_| ())),
+            DatabaseKind::City => dbreader.lookup(ip).and_then(|r| r.decode::<City>().map(|_| ())),
+            DatabaseKind::AnonymousIp => dbreader.lookup(ip).and_then(|r| r.decode::<AnonymousIp>().map(|_| ())),
         };

         match result {
@@ -165,7 +165,7 @@ impl Geoip {

         match self.dbkind {
             DatabaseKind::Asn | DatabaseKind::Isp => {
-                let data = self.dbreader.lookup::<Isp>(ip).ok()??;
+                let data = self.dbreader.lookup(ip).ok()?.decode::<Isp>().ok()??;

                 add_field!("autonomous_system_number", data.autonomous_system_number);
                 add_field!(
@@ -176,62 +176,60 @@ impl Geoip {
                 add_field!("organization", data.organization);
             }
             DatabaseKind::City => {
-                let data = self.dbreader.lookup::<City>(ip).ok()??;
+                let data = self.dbreader.lookup(ip).ok()?.decode::<City>().ok()??;

                 add_field!(
                     "city_name",
-                    self.take_translation(data.city.as_ref().and_then(|c| c.names.as_ref()))
+                    self.take_translation(&data.city.names)
                 );

-                add_field!("continent_code", data.continent.and_then(|c| c.code));
+                add_field!("continent_code", data.continent.code);

-                let country = data.country.as_ref();
-                add_field!("country_code", country.and_then(|country| country.iso_code));
+                add_field!("country_code", data.country.iso_code);
                 add_field!(
                     "country_name",
-                    self.take_translation(country.and_then(|c| c.names.as_ref()))
+                    self.take_translation(&data.country.names)
                 );

-                let location = data.location.as_ref();
-                add_field!("timezone", location.and_then(|location| location.time_zone));
+                add_field!("timezone", data.location.time_zone);
                 add_field!(
                     "latitude",
-                    location
-                        .and_then(|location| location.latitude)
+                    data.location
+                        .latitude
                         .map(|latitude| Value::Float(
                             NotNan::new(latitude).expect("latitude cannot be Nan")
                         ))
                 );
                 add_field!(
                     "longitude",
-                    location
-                        .and_then(|location| location.longitude)
+                    data.location
+                        .longitude
                         .map(|longitude| NotNan::new(longitude).expect("longitude cannot be Nan"))
                 );
                 add_field!(
                     "metro_code",
-                    location.and_then(|location| location.metro_code)
+                    data.location.metro_code
                 );

                 // last subdivision is most specific per https://github.com/maxmind/GeoIP2-java/blob/39385c6ce645374039450f57208b886cf87ade47/src/main/java/com/maxmind/geoip2/model/AbstractCityResponse.java#L96-L107
-                let subdivision = data.subdivisions.as_ref().and_then(|s| s.last());
+                let subdivision = data.subdivisions.last();
                 add_field!(
                     "region_name",
-                    self.take_translation(subdivision.and_then(|s| s.names.as_ref()))
+                    subdivision.map(|s| self.take_translation(&s.names)).flatten()
                 );
                 add_field!(
                     "region_code",
                     subdivision.and_then(|subdivision| subdivision.iso_code)
                 );
-                add_field!("postal_code", data.postal.and_then(|p| p.code));
+                add_field!("postal_code", data.postal.code);
             }
             DatabaseKind::ConnectionType => {
-                let data = self.dbreader.lookup::<ConnectionType>(ip).ok()??;
+                let data = self.dbreader.lookup(ip).ok()?.decode::<ConnectionType>().ok()??;

                 add_field!("connection_type", data.connection_type);
             }
             DatabaseKind::AnonymousIp => {
-                let data = self.dbreader.lookup::<AnonymousIp>(ip).ok()??;
+                let data = self.dbreader.lookup(ip).ok()?.decode::<AnonymousIp>().ok()??;

                 add_field!("is_anonymous", data.is_anonymous);
                 add_field!("is_anonymous_vpn", data.is_anonymous_vpn);
@@ -247,11 +245,19 @@ impl Geoip {

     fn take_translation<'a>(
         &self,
-        translations: Option<&BTreeMap<&str, &'a str>>,
+        names: &'a maxminddb::geoip2::Names<'a>,
     ) -> Option<&'a str> {
-        translations
-            .and_then(|translations| translations.get(&*self.config.locale))
-            .copied()
+        match self.config.locale.as_str() {
+            "de" => names.german.as_deref(),
+            "en" => names.english.as_deref(),
+            "es" => names.spanish.as_deref(),
+            "fr" => names.french.as_deref(),
+            "ja" => names.japanese.as_deref(),
+            "pt-BR" => names.brazilian_portuguese.as_deref(),
+            "ru" => names.russian.as_deref(),
+            "zh-CN" => names.simplified_chinese.as_deref(),
+            _ => names.english.as_deref(),
+        }
     }
 }

diff --git a/src/enrichment_tables/mmdb.rs b/src/enrichment_tables/mmdb.rs
index b8103cd60..5f3cc54f4 100644
--- a/src/enrichment_tables/mmdb.rs
+++ b/src/enrichment_tables/mmdb.rs
@@ -56,7 +56,7 @@ impl Mmdb {

         // Check if we can read database with dummy Ip.
         let ip = IpAddr::V4(std::net::Ipv4Addr::UNSPECIFIED);
-        let result = dbreader.lookup::<ObjectMap>(ip).map(|_| ());
+        let result = dbreader.lookup(ip).and_then(|r| r.decode::<ObjectMap>().map(|_| ()));

         match result {
             Ok(_) => Ok(Mmdb {
@@ -69,7 +69,7 @@ impl Mmdb {
     }

     fn lookup(&self, ip: IpAddr, select: Option<&[String]>) -> Option<ObjectMap> {
-        let data = self.dbreader.lookup::<ObjectMap>(ip).ok()??;
+        let data = self.dbreader.lookup(ip).ok()?.decode::<ObjectMap>().ok()??;

         if let Some(fields) = select {
             let mut filtered = Value::from(ObjectMap::new());
--
2.50.1
